#!/usr/bin/python

import Queue
import threading
import thread
import time

exitFlag = 0

class threadTools (threading.Thread):
   def __init__(self, threadID, name, func):
      threading.Thread.__init__(self)
      self.threadID = threadID
      self.name = name
      self.func = func
   def run(self):
      print "Starting " + self.name
      process_data(self.name, self.func)
      print "Exiting " + self.name

def process_data(threadName, func):
   while not exitFlag:
      queueLock.acquire()
         if not workQueue.empty():
            func()
            queueLock.release()
            print "%s processing %s" % (threadName, func)
         else:
            queueLock.release()
         time.sleep(1)

def create_async_multithread(funcList, dataList):
  assert_condition = True if funcList.len() == dataList.len() else False
  assert assert_condition, "Make sure Lists are equal length"
  try:
    for i in funcList:
      thread.start_new_thread(funcList[i], data[i])
  except:
    print("Error Creating Thread")


def create_priority_queue(funcList):
  threadList = ["Thread-1", "Thread-2", "Thread-3"]
  queueLock = threading.Lock()
  workQueue = Queue.Queue(10)
  threads = []
  threadID = 1

  # Create new threads
  for tName in threadList:
     thread = myThread(threadID, tName, workQueue)
     thread.start()
     threads.append(thread)
     threadID += 1

  # Fill the queue
  queueLock.acquire()
  for func in funcList:
     workQueue.put(func)
  queueLock.release()

  # Wait for queue to empty
  while not workQueue.empty():
     pass
  
  # Notify threads it's time to exit
  exitFlag = 1
  
  # Wait for all threads to complete
  for t in threads:
     t.join()
  print "Exiting Main Thread"
